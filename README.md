# Ruby on Rails Juniors

## Введение в профессиональную разработку на Ruby on Rails

#### Начало работы

Последовательность команд для установки Ruby on Rails на Ubuntu:

```bash
sudo apt-get update -y
sudo apt-get install build-essential bison openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev nodejs -y
curl -L get.rvm.io | bash -s stable
source ~/.rvm/scripts/rvm
rvm install 2.1.1
rvm use 2.1.1 --default
gem install rails --no-rdoc --no-ri
```

После этого становится доступной команда создания нового rails-приложения `rails new {applicaion name}`. Затем необходимо перейти в каталог созданного приложения и запустить rails-сервер командой `rails s`. После этого приложение становится доступным в браузере на [localhost:3000](http://localhost:3000).

Пример создания приложения `first_app` и запуска его сервера:

```bash
rails new first_app
cd first_app
rails s
```

Чтобы запустить сервер на другом порте, необходимо указать номер порта с ключом `-p`:
```
rails s -p 5555
```
запустит сервер на порте 5555, и в браузере приложение нужно будет искать на [localhost:5555](http://localhost:5555).

#### Getting started: приступая к работе
В этом практическом задании рассмотрено большое количество очень разных вопросов, объединенных, тем не менее, плотным смысловым единством _(состоящим, пожалуй, в том, без всех этих вещей ни с одним rails-приложением нельзя сделать почти ничего)_:
- **Bundler** - пакетный менеджер Rails;
- язык описания представлений (views) **Slim**;
- **Twitter Bootstrap** для **Asset pipeline**;
- контроллер статических страниц;
- введение в роутинг;
- первое знакомство с хелперами.

В качестве бонуса освоим работу с хелпером `content_for`, который вовсе не так общезначим, но может иногда пригодиться.

Устанавливаем slim — в `Gemfile` добавляем
```ruby
gem 'slim-rails'
```
В каталоге приложения запускаем команду
```bash
bundle install
```
Впрочем, install — это наиболее востребованная операция Bundler'a, которая делается им по умолчанию, поэтому `bundle install`, как правило сокращается просто до
```
bundle
```
Это нужно делать всегда после обновления `Gemfile`, больше не будем на этом останавливаться.

Теперь мы можем создавать вьюхи на slim'e. Кроме того, теперь, когда мы выбрали язык описания представлений, можно установить [**Twitter Bootstrap**](https://github.com/seyhunak/twitter-bootstrap-rails).

Читаем документацию в readme по ссылке _(привыкаем к этому, это теперь на всю профессиональную жизнь в Rails)_, осмысливаем и делаем только то, что нам нужно:

Добавляем в `Gemfile`:
```ruby
gem 'therubyracer'
gem 'less-rails'
gem 'twitter-bootstrap-rails'
```
Затем запустим в каталоге приложения генераторы необходимых стилевых таблиц
```
rails generate bootstrap:install less
```
Теперь можно бегло глянуть `application.css` и `application.js`, чтобы примерно понять, как работает **Asset pipeline**, а позже обязательно внимательно прочитать [документацию](http://guides.rubyonrails.org/asset_pipeline.html).

Тем не менее, не отвлекаемся сильно и создаем главный layout приложения (здесь и далее: команда `rails` всегда выполняется в каталоге приложения):
```
rails g bootstrap:layout application fluid
```
Удаляем старый ужасный `application.html.erb` из `/app/views/layouts/`, и, чтобы увидеть значительные изменения, создаем контроллер статических страниц, воспользовавшись диалогом RubyMine или выполнив команду
```
rails g controller Page home index about info test
```
Выполнить команду, пожалуй, даже интереснее — ознакомление со списком созданных файлов в этом случае происходит более наглядно.

Теперь пора познакомиться с системой автоматической сборки кода **Rake** и запросить у нее список обслуживаемых приложением путей (здесь и далее: команда `rake` точно так же всегда запускается в каталоге приложения):
```
rake routes
```
Теперь на [localhost:3000](http://localhost:3000) нам открыты все пути, перечисленные в `rake routes`! _Если не открыты, запустите сервер и не забывайте его включать и выключать по необходимости — это тоже очень важный навык._

Однако в самом корне [localhost:3000](http://localhost:3000) пока еще стартовая страница по умолчанию.

В `routes.rb` (который находится в папке `/config` приложения) пишем
```ruby
root 'page#home'
```
или, для большего соответствия с полным синтаксисом `routes.rb`
```ruby
root to: 'page#home'
```
Работать будет и так, и так — делайте выбор из ваших синтаксических предпочтений. С помощью команды `root` можно направить корневой адрес приложения любому действию (action) любого контроллера, указав их в _(желательно одинарных)_ кавычках в формате `:controller#:action`.

Полностью команда настройки статического пути выглядит так:
```ruby
get '{:path}', to: ':controller#:action', as: {:alias}
```
Рассмотрим на примере:
```ruby
get 'page', to: 'page#index', as: :page
```
Все примерно понятно и знакомо, но зачем же alias? Снова запустим `rake routes` и найдем все элиасы в первой колонке таблицы, озаглавленном **Prefix**.
Теперь в `application.html.slim` (который, мы помним, в `/app/views/layouts`) найдем ссылки в шапке сайта и поправим их в соответствии со структурой нашего приложения:
```ruby
li = link_to 'Pages index', :page
```
Первый и, пожалуй, самый важный встреченный нами хелпер _**(ruby-функция rails, генерирующая html-код на основании переданных параметров)**_ `link_to` применяется, очевидно, для описания ссылок и первым параметром принимает текст или html-код отображения ссылки, вторым — адрес, на который будет указывать ссылка. Далее можно будет указать дополнительные параметры, как то `style:` или `class:`, но об этом позже. Адрес ссылки можно задать, помимо уже известного, еще двумя способами:
```ruby
li = link_to 'Pages index', page_path
```
и
```ruby
li = link_to 'Pages index', page_url
```
Встроенные методы rails `{:prefix}_path` и `{:prefix}_url` создадут соответственно относительный от корня сайта адрес страницы и абсолютный url, включающий адрес сайта. На локалхосте разницу, конечно, не заметить, но знать это надо. Вот мы и разобрались с префиксами роутов.

Продолжаем. В `routes.rb` пишем что-то вроде
```ruby
get 'any/other/page/anywhere/at/your/site', to: 'page#info', as: :info
```
в `application.html.slim`
```ruby
li = link_to 'Cool page', :info
```
Обновляем страничку, давим ссылку, читаем url в браузере и наслаждаемся полнотой своего понимания статического роутинга.

Теперь самое время заменить ужасную html-ную ссылку на главную страницу, которая, ко всем прочим недостаткам, из коробки `twitter bootstrap gem` еще и не работает (видимо, по каким-то серьезным идейным соображениям). Меняем
```
a.brand href="#"{:app_name}
```
на
```ruby
= link_to 'Practice', :root, class: %i[brand]
```
И запоминаем на всю жизнь, что тегов `a` во вьюхах рельсов **не бывает**. Для этого мы только что с таким трудом изучали соответствующий хелпер.

Еще об одном хелпере — `content_for`. В `application.html.slim` есть многообещающее
```ruby
title = content_for?(:title) ? yield(:title) : "Practice"
```
Как же задать этот title? _(использованный здесь тернарный оператор, конечно же, всем знаком)_ В любой взятой наугад вьюхе, например, `app/views/page/index.html.slim`, лучше всего в самой первой строчке, пишем:
```ruby
- content_for :title
  | Проникновенный и точный заголовок индексной страницы по умолчанию
```
И это, собственно, все. Сравниваем с заголовками вьюх, где `content_for :title` не определен и озаряемся пониманием.

Для закрепления поменяем последнюю ссылку в сайдбаре на
```ruby
li = content_for?(:sidebar) ? yield(:sidebar) : link_to("Link 3", "/path3")
```
Соответственно, во вьюхе, в которой мы хотим заменять эту ссылку, пишем, например:
```ruby
- content_for :sidebar
  - link_to 'Home Sweet Home', :root, style: 'color:green'
```
Вот, собственно, и весь `content_for` — второй хелпер, рассмотренный в этом курсе. Их еще много, и пора переходить к следующему занятию, где мы поближе познакомимся со странными двоеточими в начале некоторых слов, имеющими прямое отношение к важным различиям между символами и строками в ruby, и, возможно, даже с процентными литералами.

Можно пока остальные ссылки в лэйауте приложения допилить и все `content_for` снести. Ну, или, наоборот, добавить, если эффект понравился.

#### Getting continued: немного Ruby и FizzBuzz-тест (beginner & NIGHTMARE)

В ходе этой небольшой, но важной работы мы
- сформулируем самое общее представление о Ruby как о языке программирования;
- узнаем самые важные вещи об объектной модели Ruby;
- выделим самый важный класс объектов не только Ruby, а, возможно, всей Computer science;
- разберемся наконец с разницей между символами и строками в Ruby;
- сделаем простейшую реализацию принципа duck typing;
- немного затронем регулярные выражения и процентные литералы;
- слегка прикоснемся к магии Ruby — доброй и не очень;
- **а также проверим свои навыки постановки и решения прикладных задач**.

Запустим рельсовую консоль (здесь и далее: в каталоге приложения `rails c`) и запишем — вот прямо подряд:
```ruby
class String
def palindrome?
self == self.reverse
end
end
```
Проверяем:
```ruby
'deified'.palindrome?
```
```ruby
'olol'.palindrome?
```
```ruby
'ololo'.palindrome?
```
Смотрим и делаем ряд важных выводов:
- Ruby — один из самых объектно ориентированных языков. Объекты здесь везде;
- Ruby way — это всегда вызов метода объекта на объекте через точку;
- в Ruby можно дополнять описания встроенных системных классов;
- в Ruby принято дополнять имена проверяющих функций вопросительным знаком (привет `content_for?`!);
- _к слову: методы с восклицательным знаком, как правило, изменяют объект, на котором они вызваны;_
- метод возвращает последнее упомянутое в коде значение, `return` нужно использовать только тогда, когда код сложный и есть вероятность возникновения путаницы.

А также несколько не очень важных:
- рельсовая консоль красиво расставляет отступы;
- а в случае использования гема `pry-rails` еще и делает красивую подсветку синтаксиса.

Кто еще не поставил `pry-rails`, ставит:
```ruby
gem 'pry-rails'
```
в `Gemfile`, конечно. Здесь и далее.

Осваиваем конструкцию диапазона `(a..b)`, итератор `each`, однострочный блок `{ |variable| code(variable) }` и команду вывода `puts`:
```ruby
def count_to(limit)
  (1..limit).each { |i| puts i }
end
```
Вызов, само собой:
```ruby
count_to(10)
```
или даже
```ruby
count_to 10
```
Это есть такой в Ruby синтаксический сахар — передача аргументов методу без скобок. Удобно иногда, хотя лучше этим не увлекаться — от такого сахара по сути правильный код иногда вдруг внезапно перестает работать (обратите внимание, что в примере с `content_for :sidebar` аргументы `link_to` пришлось взять в скобки, и неспроста).

Еще немного:
```ruby
def count_to(limit)
  (1..limit).each do |i|
    print i
  end
end
```
Это, соответственно, многострочный блок и команда `print`.

Чтобы чуть облагородить вывод команды `print`, освоим интерполируемые строки (это которые в двойных кавычках, в отличие от неинтерполируемых в одинарных — знакомая во многих языках практика). К слову о культуре кода, следите постоянно за тем, чтобы в двойных кавычках обязательно происходила какая-нибудь интерполяция. Если ее нет, одинарные кавычки обязательны. Код читать будет намного удобнее.

Итак:
```ruby
def count_to(limit)
  (1..limit).each { |i| print "#{i}\n" }
end
```

Сформируем массив значений:
```ruby
def count_to(limit)
  (1..limit).map { |i| i }
end
```

Вот еще красивая практика для сокращения записи одного подвида тернарных операторов:
```ruby
['Fizz'][0]
```
```ruby
['Fizz'][1]
```
```ruby
['Fizz'][100500]
```
Все это значит, что в Ruby первый индекс массива — 0, а обращение к элементу массива с несуществующим индексом не выдает ошибки, а только `nil` — отсутствующее значение. Разовьем мысль:
```ruby
"#{['Fizz'][0]}"
```
```ruby
"#{['Fizz'][100500]}"
```
К слову. Метод `blank?` проверяет, является ли строка пустой. Еще к слову: если вы хотите вызвать какой-либо метод на объекте, генерируемом каким-либо оператором, возьмите этот оператор в скобки.

Вот и все. Теперь вы готовы к тому, чтобы почти мгновенно написать красивое однострочное решение для FizzBuzz-теста на Ruby:

> Определить функцию от двух аргументов, возвращающую массив целых чисел от одного аргумента до другого, обработанных так:
> - если число делится без остатка на 3, вернуть 'Fizz';
> - если число делится без остатка на 5, вернуть 'Buzz';
> - если и на 3 и на 5, конечно же, 'FizzBuzz';
> - если число не делится ни на 3, ни на 5, вернуть само число.

_**Подсказка 1:**_ Первый аргумент не обязательно меньше второго.

_**Подсказка 2:**_ Остаток от деления i на 3 — это `i%3`. Можно пользоваться справочниками по [операторам](http://www.tutorialspoint.com/ruby/ruby_operators.htm), [циклам](http://www.tutorialspoint.com/ruby/ruby_loops.htm) и [ветвлениям](http://www.tutorialspoint.com/ruby/ruby_if_else.htm) в Ruby.

_**Подсказка 3:**_ Ни сейчас, ни когда-либо еще не используйте `for {:variable} in {:array}`. Это совсем не Ruby way, не создает локальной области видимости переменных, и вообще некрасиво.
