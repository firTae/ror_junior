# Ruby on Rails Juniors

## Введение в профессиональную разработку на Ruby on Rails

#### Начало работы

Последовательность команд для установки Ruby on Rails на Ubuntu:

```bash
sudo apt-get update -y
sudo apt-get install build-essential bison openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev nodejs -y
curl -L get.rvm.io | bash -s stable
source ~/.rvm/scripts/rvm
rvm install 2.1.1
rvm use 2.1.1 --default
gem install rails --no-rdoc --no-ri
```

После этого становится доступной команда создания нового rails-приложения `rails new {applicaion name}`. Затем необходимо перейти в каталог созданного приложения и запустить rails-сервер командой `rails s`. После этого приложение становится доступным в браузере на [localhost:3000](http://localhost:3000).

Пример создания приложения `first_app` и запуска его сервера:

```bash
rails new first_app
cd first_app
rails s
```

Чтобы запустить сервер на другом порте, необходимо указать номер порта с ключом `-p`:
```
rails s -p 5555
```
запустит сервер на порте 5555, и в браузере приложение нужно будет искать на [localhost:5555](http://localhost:5555).

#### Getting started: приступая к работе
В этом практическом задании рассмотрено большое количество очень разных вопросов, объединенных, тем не менее, плотным смысловым единством _(состоящим, пожалуй, в том, без всех этих вещей ни с одним rails-приложением нельзя сделать почти ничего)_:
- **Bundler** - пакетный менеджер Rails;
- язык описания представлений (views) **Slim**;
- **Twitter Bootstrap** для **Asset pipeline**;
- контроллер статических страниц;
- введение в роутинг;
- первое знакомство с хелперами.

В качестве бонуса освоим работу с хелпером `content_for`, который вовсе не так общезначим, но может иногда пригодиться.

Устанавливаем slim — в `Gemfile` добавляем
```ruby
gem 'slim-rails'
```
В каталоге приложения запускаем команду
```bash
bundle install
```
Впрочем, install — это наиболее востребованная операция Bundler'a, которая делается им по умолчанию, поэтому `bundle install`, как правило сокращается просто до
```
bundle
```
Это нужно делать всегда после обновления `Gemfile`, больше не будем на этом останавливаться.

Теперь мы можем создавать вьюхи на slim'e (Постоянно держа под рукой его [мануал](http://rdoc.info/gems/slim/frames)). Кроме того, теперь, когда мы выбрали язык описания представлений, можно установить [**Twitter Bootstrap**](https://github.com/seyhunak/twitter-bootstrap-rails).

Читаем документацию в readme по ссылке _(привыкаем к этому, это теперь на всю профессиональную жизнь в Rails)_, осмысливаем и делаем только то, что нам нужно:

Добавляем в `Gemfile`:
```ruby
gem 'therubyracer'
gem 'less-rails'
gem 'twitter-bootstrap-rails'
```
Затем запустим в каталоге приложения генераторы необходимых стилевых таблиц
```
rails generate bootstrap:install less
```
Теперь можно бегло глянуть `application.css` и `application.js`, чтобы примерно понять, как работает **Asset pipeline**, а позже обязательно внимательно прочитать [документацию](http://guides.rubyonrails.org/asset_pipeline.html).

Тем не менее, не отвлекаемся сильно и создаем главный layout приложения (здесь и далее: команда `rails` всегда выполняется в каталоге приложения):
```
rails g bootstrap:layout application fluid
```
Удаляем старый ужасный `application.html.erb` из `/app/views/layouts/`, и, чтобы увидеть значительные изменения, создаем контроллер статических страниц, воспользовавшись диалогом RubyMine или выполнив команду
```
rails g controller Page home index about info test
```
Выполнить команду, пожалуй, даже интереснее — ознакомление со списком созданных файлов в этом случае происходит более наглядно.

Теперь пора познакомиться с системой автоматической сборки кода **Rake** и запросить у нее список обслуживаемых приложением путей (здесь и далее: команда `rake` точно так же всегда запускается в каталоге приложения):
```
rake routes
```
Теперь на [localhost:3000](http://localhost:3000) нам открыты все пути, перечисленные в `rake routes`! _Если не открыты, запустите сервер и не забывайте его включать и выключать по необходимости — это тоже очень важный навык._

Однако в самом корне [localhost:3000](http://localhost:3000) пока еще стартовая страница по умолчанию.

В `routes.rb` (который находится в папке `/config` приложения) пишем
```ruby
root 'page#home'
```
или, для большего соответствия с полным синтаксисом `routes.rb`
```ruby
root to: 'page#home'
```
Работать будет и так, и так — делайте выбор из ваших синтаксических предпочтений. С помощью команды `root` можно направить корневой адрес приложения любому действию (action) любого контроллера, указав их в _(желательно одинарных)_ кавычках в формате `:controller#:action`.

Полностью команда настройки статического пути выглядит так:
```ruby
get '{:path}', to: ':controller#:action', as: {:alias}
```
Рассмотрим на примере:
```ruby
get 'page', to: 'page#index', as: :page
```
Все примерно понятно и знакомо, но зачем же alias? Снова запустим `rake routes` и найдем все элиасы в первой колонке таблицы, озаглавленном **Prefix**.
Теперь в `application.html.slim` (который, мы помним, в `/app/views/layouts`) найдем ссылки в шапке сайта и поправим их в соответствии со структурой нашего приложения:
```ruby
li = link_to 'Pages index', :page
```
Первый и, пожалуй, самый важный встреченный нами хелпер _**(ruby-функция rails, генерирующая html-код на основании переданных параметров)**_ `link_to` применяется, очевидно, для описания ссылок и первым параметром принимает текст или html-код отображения ссылки, вторым — адрес, на который будет указывать ссылка. Далее можно будет указать дополнительные параметры, как то `style:` или `class:`, но об этом позже. Адрес ссылки можно задать, помимо уже известного, еще двумя способами:
```ruby
li = link_to 'Pages index', page_path
```
и
```ruby
li = link_to 'Pages index', page_url
```
Встроенные методы rails `{:prefix}_path` и `{:prefix}_url` создадут соответственно относительный от корня сайта адрес страницы и абсолютный url, включающий адрес сайта. На локалхосте разницу, конечно, не заметить, но знать это надо. Вот мы и разобрались с префиксами роутов.

Продолжаем. В `routes.rb` пишем что-то вроде
```ruby
get 'any/other/page/anywhere/at/your/site', to: 'page#info', as: :info
```
в `application.html.slim`
```ruby
li = link_to 'Cool page', :info
```
Обновляем страничку, давим ссылку, читаем url в браузере и наслаждаемся полнотой своего понимания статического роутинга.

Теперь самое время заменить ужасную html-ную ссылку на главную страницу, которая, ко всем прочим недостаткам, из коробки `twitter bootstrap gem` еще и не работает (видимо, по каким-то серьезным идейным соображениям). Меняем
```
a.brand href="#"{:app_name}
```
на
```ruby
= link_to 'Practice', :root, class: %i[brand]
```
И запоминаем на всю жизнь, что тегов `a` во вьюхах рельсов **не бывает**. Для этого мы только что с таким трудом изучали соответствующий хелпер.

Еще об одном хелпере — `content_for`. В `application.html.slim` есть многообещающее
```ruby
title = content_for?(:title) ? yield(:title) : "Practice"
```
Как же задать этот title? _(использованный здесь тернарный оператор, конечно же, всем знаком)_ В любой взятой наугад вьюхе, например, `app/views/page/index.html.slim`, лучше всего в самой первой строчке, пишем:
```ruby
- content_for :title
  | Проникновенный и точный заголовок индексной страницы по умолчанию
```
И это, собственно, все. Сравниваем с заголовками вьюх, где `content_for :title` не определен и озаряемся пониманием.

Для закрепления поменяем последнюю ссылку в сайдбаре на
```ruby
li = content_for?(:sidebar) ? yield(:sidebar) : link_to("Link 3", "/path3")
```
Соответственно, во вьюхе, в которой мы хотим заменять эту ссылку, пишем, например:
```ruby
- content_for :sidebar
  - link_to 'Home Sweet Home', :root, style: 'color:green'
```
Вот, собственно, и весь `content_for` — второй хелпер, рассмотренный в этом курсе. Их еще много, и пора переходить к следующему занятию, где мы поближе познакомимся со странными двоеточими в начале некоторых слов, имеющими прямое отношение к важным различиям между символами и строками в ruby, и, возможно, даже с процентными литералами.

Можно пока остальные ссылки в лэйауте приложения допилить и все `content_for` снести. Ну, или, наоборот, добавить, если эффект понравился.

#### Getting continued: немного Ruby и FizzBuzz-тест (beginner & NIGHTMARE)

В ходе этой небольшой, но важной работы мы
- сформулируем самое общее представление о Ruby как о языке программирования;
- узнаем самые важные вещи об объектной модели Ruby;
- выделим самый важный класс объектов не только Ruby, а, возможно, всей Computer science;
- разберемся наконец с разницей между символами и строками в Ruby;
- сделаем простейшую реализацию принципа duck typing;
- слегка прикоснемся к магии Ruby — доброй и не очень;
- немного затронем регулярные выражения и процентные литералы;
- **а также проверим свои навыки постановки и решения прикладных задач**.

Запустим рельсовую консоль (здесь и далее: в каталоге приложения `rails c`) и запишем — вот прямо подряд:
```ruby
class String
def palindrome?
self == self.reverse
end
end
```
Проверяем:
```ruby
'deified'.palindrome?
```
```ruby
'olol'.palindrome?
```
```ruby
'ololo'.palindrome?
```
Смотрим и делаем ряд важных выводов:
- Ruby — один из самых объектно ориентированных языков. Объекты здесь везде;
- Ruby way — это всегда вызов метода объекта на объекте через точку;
- в Ruby можно дополнять описания встроенных системных классов;
- в Ruby принято дополнять имена проверяющих функций вопросительным знаком (привет `content_for?`!);
- _к слову: методы с восклицательным знаком, как правило, изменяют объект, на котором они вызваны;_
- метод возвращает последнее упомянутое в коде значение, `return` нужно использовать только тогда, когда код сложный и есть вероятность возникновения путаницы.

А также несколько не очень важных:
- рельсовая консоль красиво расставляет отступы;
- а в случае использования гема `pry-rails` еще и делает красивую подсветку синтаксиса.

Кто еще не поставил `pry-rails`, ставит:
```ruby
gem 'pry-rails'
```
в `Gemfile`, конечно. Здесь и далее.

Осваиваем конструкцию диапазона `(a..b)`, итератор `each`, однострочный блок `{ |variable| code(variable) }` и команду вывода `puts`:
```ruby
def count_to(limit)
  (1..limit).each { |i| puts i }
end
```
Вызов, само собой:
```ruby
count_to(10)
```
или даже
```ruby
count_to 10
```
Это есть такой в Ruby синтаксический сахар — передача аргументов методу без скобок. Удобно иногда, хотя лучше этим не увлекаться — от такого сахара по сути правильный код иногда вдруг внезапно перестает работать (обратите внимание, что в примере с `content_for :sidebar` аргументы `link_to` пришлось взять в скобки, и неспроста).

Еще немного:
```ruby
def count_to(limit)
  (1..limit).each do |i|
    print i
  end
end
```
Это, соответственно, многострочный блок и команда `print`.

Чтобы чуть облагородить вывод команды `print`, освоим интерполируемые строки (это которые в двойных кавычках, в отличие от неинтерполируемых в одинарных — знакомая во многих языках практика). К слову о культуре кода, следите постоянно за тем, чтобы в двойных кавычках обязательно происходила какая-нибудь интерполяция. Если ее нет, одинарные кавычки обязательны. Код читать будет намного удобнее.

Итак:
```ruby
def count_to(limit)
  (1..limit).each { |i| print "#{i}\n" }
end
```

Сформируем массив значений:
```ruby
def count_to(limit)
  (1..limit).map { |i| i }
end
```

Вот еще красивая практика для сокращения записи одного подвида тернарных операторов:
```ruby
['Fizz'][0]
```
```ruby
['Fizz'][1]
```
```ruby
['Fizz'][100500]
```
Все это значит, что в Ruby первый индекс массива — 0, а обращение к элементу массива с несуществующим индексом не выдает ошибки, а только `nil` — отсутствующее значение. Разовьем мысль:
```ruby
"#{['Fizz'][0]}"
```
```ruby
"#{['Fizz'][100500]}"
```
К слову. Метод `blank?` проверяет, является ли строка пустой. Еще к слову: если вы хотите вызвать какой-либо метод на объекте, генерируемом каким-либо оператором, возьмите этот оператор в скобки.

Вот и все. Теперь вы готовы к тому, чтобы почти мгновенно написать красивое однострочное решение для FizzBuzz-теста на Ruby:

> Определить функцию от двух аргументов, возвращающую массив целых чисел от одного аргумента до другого, обработанных так:
> - если число делится без остатка на 3, вернуть «Fizz»;
> - если число делится без остатка на 5, вернуть «Buzz»;
> - если и на 3 и на 5, конечно же, «FizzBuzz»;
> - если число не делится ни на 3, ни на 5, вернуть само число.

_**Подсказка 1:**_ Первый аргумент не обязательно меньше второго.

_**Подсказка 2:**_ Остаток от деления i на 3 — это `i%3`. Можно пользоваться справочниками по [операторам](http://www.tutorialspoint.com/ruby/ruby_operators.htm), [циклам](http://www.tutorialspoint.com/ruby/ruby_loops.htm) и [ветвлениям](http://www.tutorialspoint.com/ruby/ruby_if_else.htm) в Ruby.

_**Подсказка 3:**_ Ни сейчас, ни когда-либо еще не используйте `for {:variable} in {:array}`. Это совсем не Ruby way, не создает локальной области видимости переменных, и вообще некрасиво.

Когда тест готов, синтаксически совершенен и абсолютно работоспособен, наступает время опустить скучные модификации вроде **FizzBuzzEazzCozzDezz** и сделать все вовсе по-взрослому. На **NIGHTMARE** мы будем делать этот тест:
- принимая массив делителей как аргумент функции;
- и представляя числа как произведения своих делителей и остатка деления.

То есть, все просто. `fizzBuzzNigthmare(1,100,3,5)` должна нам выдавать `'3x2'` на 6, `'5x2'` на 10, `'3x5'` на 15 и так далее. Отложим пока фильтрацию ввода и сделаем пока чистую реализацию алгоритма, предполагая, что в массиве делителей не будет неприятных неожиданностей. Однако обязательно подумаем об этом позже.

А сейчас необходимо освоить несколько технических моментов как Ruby, так и Rails.

Прием массива как аргумента функции с помощью `*` (заодно раскроем тему точек с запятой в Ruby):
```ruby
def checkArrayArg(a, b, *c)
  puts a; puts b; puts c.inspect
end
```
Проверяем:
```ruby
checkArrayArg(1,100,-1,0,1,2,3,5,7,4,10)
```
Это Ruby, здесь просто. А вот в рельсах есть MVC с роутингом, здесь все сложнее — чтобы получить такой же REPL в rails-приложении, нужно подергать и роутинг, и контроллеры, и вьюхи.

Вернемся к чуть более простому случаю — приему обычных параметров из url.

В `routes.rb` добавляем
```ruby
get 'test/:a/:b', to: 'page#test'
```
В `page_controller.rb`:
```ruby
def test
  @a, @b = params[:a], params[:b]
end
```
В `page/test.html.slim`:
```ruby
p = @a
p = @b
```
Вот и все, [наслаждаемся](http://localhost:3000/test/first_param=1/second_param=100500)

С массивом в качестве аргумента все до обидного аналогично и тривиально:
В `routes.rb`:
```ruby
get 'test/:a/:b/*c', to: 'page#test'
```
В `page_controller.rb`:
```ruby
def test
  @a, @b, @c = params[:a], params[:b], params[:c].split('/')
end
```
В `page/test.html.slim`:
```ruby
p = @a
p = @b
p = @c.inspect
```
Можно принять несколько массивов из одного запроса, используя разделитель:

В `routes.rb`:
```ruby
get 'test/:a/:b/*c/div/*d', to: 'page#test'
```
В `page_controller.rb`:
```ruby
def test
  @a, @b, @c, @d = params[:a], params[:b], params[:c].split('/'), params[:d].split('/')
end
```
В `page/test.html.slim`:
```ruby
p = @a
p = @b
p = @c.inspect
p = @d.inspect
```
Распилив пришедший параметр по разделителю методом `split`, мы более явно, чем в случае с одиночным параметром, убедились в том, что в параметрах запроса все значения приходят строками. Чтобы получить из них целые числа, следует воспользоваться методом `to_i` (to integer). Кстати, есть еще `to_s` для приведения к строкам, `to_f` к числам с точкой. Есть много других типов и методов для приведения к ним, и их можно будет освоить самостоятельно.

Подытожим: таким образом, корректное получение числовых значений из параметров запроса будет выглядеть так:
```ruby
def test
  @a, @b, @c = params[:a].to_i, params[:b].to_i, params[:c].split('/').map(&:to_i)
end
```
Тем, кто хорошо сделал домашнее задание, уже понятно все произошедшее. Для остальных поясню, что в метод `map` мы передали так называемую лямбду — блок, который вызывает на каждом элементе обрабатываемого им блока указанный метод и возвращает результат этого метода. А `map`, в свою очередь, записывает все полученные таким образом данные в массив.

Вот, кстати, дополнительная задача для будущих суровых well-grounded рубистов:
> Добавить в системный класс Fixnum описание метода `fizzBuzz`, который будет возвращать результат FizzBuzz-преобразования и вот так вот красиво работать через лямбду:
> ```ruby
> (1..100).map(&:fizzBuzz)
> ```

У кого получилось, может считать себя прикоснувшимся к доброй магии Ruby.

Однако нам потребуется еще несколько инструментов. Осваиваем:

Выбрать элементы массива, на которых условие выполняется:
```ruby
[2,3,5,7,11].select { |i| 55%i == 0 }
```
Посчитать размер массива:
```ruby
[2,3,5,7,11].select { |i| 55%i == 0 }.size
```
Удалить элементы массива, если условие выполняется:
```ruby
[-1,0,1,2,3,5,7,11,4,6,10].delete_if { |i| i < 2 }
```
Красиво вывести массив через разделитель:
```ruby
[2,3,5,7,11,].join('x')
```
*И вообще, `Array` — один из важнейших объектов не только Ruby, но и всей Computer Science вообще. Насколько это возможно близкое знакомство с [документацией класса Array](http://www.ruby-doc.org/core-2.1.1/Array.html) в высшей степени рекомендуется. То, что в списке классов `Array` стоит первым, поверьте, не случайность.*

Однако, еще немного инструкций по мелочи.

Найти наибольший обший делитель:
```ruby
55.gcd(99)
```
Еще вот прямо совсем подсказка:
```ruby
a = 1024
5.times { a /= 2 }
puts a
```
Еще немного о рабочей среде: для того, чтобы работа с ошибками рельсов шла более эффективно, необходимо поставить еще пару гемов:
```ruby
gem 'better_errors'
gem 'binding_of_caller'
```
Вот и все. Теперь вас не остановит даже FizzBuzz тест на NIGHTMARE. А внимательные читатели уже готовы сделать и фильтрацию ввода тоже.

##### О символах и duck typing

Пора, однако, раз и навсегда разобраться с уже порядком намозолившими глаза символами. Символы — это неизменяемые строки Ruby, имена собственные. Названия полей, методов, всех объектов вообще, ключи в хэшах — всегда символы. Символы очень похожи на строки, и их довольно легко получить друг из друга методами `to_s` и `to_sym` соответственно.

Существенная разница между ними состоит в том, что выделение памяти для хранения символов более экономно, оно не предполагает, что с символом будет происходить то, что обычно часто происходит со строками — изменение, разбиение, вычленение, добавление, проверка регулярным выражением. И самое главное — что каждый символ присутствует в памяти в единственном экземпляре.

Берегите память. Если не собираетесь изменять какую-либо строку — так и скажите, что она символ. Когда ваш проект окажется под высокой нагрузкой, будете себе за это очень благодарны.

К практике. Убедимся, что этот пример выдает ошибку:
```ruby
:some_symbol.to_i
```
*(как хорошо, что у нас все на одной странице, и то, что про ошибку я сказал до приведения кода примера. Заставить этот фрагмент работать, конечно, можно, добавив в определение системного класса `Symbol` описание метода `to_i`, но здесь как раз не нужно пользоваться этой восхитительной гибкостью Ruby)*

Это означает, к примеру, что такого рода фильтрация с приведением к целым числам
```ruby
def with_filtering(a,b,*c)
  c.map!(&:to_i)
end
```
Справится и с числами с точкой, и со строками, а вот одним-разъединственным символом подавится. Что же делать? Так
```ruby
:some_symbol.to_s.to_i
```
конечно же, сработает. Но что же нам теперь, все через строки конвертировать? Нет, конечно. Есть способ понять, определен ли какой-либо метод для этого объекта или нет.
```ruby
class Object
  def integerize!
    self.respond_to?(:to_i) ? self.to_i : self.to_s.to_i
  end
end
```
Теперь приобщим к этому величию нашу функцию фильтрации:
```ruby
def with_filtering(a,b,*c)
  c.map!(&:integerize!)
end
```
Бинго! Теперь наша фильтрация не давится символами, а мы получили опыт использования принципа duck typing. Подробнее о том, что это такое, зачем это нужно и почему это важно, хотя бы [здесь](http://ru.wikipedia.org/wiki/Утиная_типизация) и, например, [здесь](http://rubylearning.com/satishtalim/duck_typing.html).

##### Не вся магия одинаково полезна
Определим функцию, которая должна возвращать единицу, так:
```ruby
def dirty_magic
  def dirty_magic
    def dirty_magic
      def dirty_magic
        def dirty_magic
          def dirty_magic
            def dirty_magic
            1
            end
          2
          end
        3
        end
      4
      end
    5
    end
  6
  end
7
end
```
И будем вызывать ее до тех пор, пока она не станет устойчиво возвращать единицу.

Сверхгибкий язык программирования Ruby позволяет создавать эффективнейшие средства троллинга отдела тестирования. Если таким образом определить какой-либо экшн какого-либо контроллера, эффект сохранится. Каждый перезапуск сервера будет запускать такой генератор блуждающих неисправностей заново. Очень удобно: спринт стремительно заканчивается, по проекту гуляют блуждающие ошибки, тестировщики седеют, подавая пачки тщательно оформленных багрепортов, а вы спокойно занимаетесь своими делами, зная, что можете решить 90% поставленных вам задач одним движением. Ценнейший для командной работы навык.

> Хорошо бы придумать какое-то практическое применение для этого эффекта, которое не связано с вредительством. У меня пока не получилось.

Что здесь произошло: внутри объявления функции `dirty_magic` мы можем производить объявления функции с тем же названием `dirty_magic` практически без ограничений. При вызове она будет определять функцию с названием `dirty_magic` (воздержимся от чересчур метафизичной формулировки «переопределять саму себя») и помимо этого делать что-то еще — в данном случае возвращать ту или иную цифру. Для Ruby (хоть в интерпретируемом, хоть в компилируемом варианте) такая цепочка переопределений не представляет проблемы — у нас всегда есть тем или иным способом определенная функция `dirty_magic`, которой никто не запрещает определять функцию с названием `dirty_magic`.

Для нас же это не хорошо и не плохо. Так устроен язык Ruby, и об этих особенностях нужно знать, даже если непонятно, как это применить.

С самыми подробными объяснениями этого эффекта и принципа рекомендуется ознакомиться [здесь](https://github.com/Vassiliy/ror_junior/issues/1).

*Чуть позже, возможно, через пару дней, здесь появится описание бонусной лабораторной работы по подходам к работе с объектами на Ruby on Rails.*

##### Регулярные выражения и процентные литералы
Предположим, мы уже решили задачу и хотим красиво, по-бутстраповски вывести результаты. Пишем во вьюхе:
```ruby
- @result.each do |result|
  span class=%i[btn btn-large] class="btn-#{/\A\d+\Z/.match(result) ? 'danger' : 'success'}" style='margin:4px' = result
```
Тем, кто знаком с регулярными выражениями, уже почти все понятно. Стоит разве что напомнить, что регулярным выражением можно проверять многострочные последовательности, и `\A` и `\Z` означают соответственно начало и конец **всей проверяемой последовательности**. Привычные `^` и `$` работают, конечно, но означают начало и конец строки — возможно, одной из многих. Будьте внимательны.

Процентные литералы позволяют экономить символы на запятых, кавычках, двоеточих и прочей пунктуации, и тем значительно улучшают читаемость кода.

Массив символов:
```ruby
%i[one two three four five six seven eight nine ten]
```
Массив строк:
```ruby
%w[one two three four five six seven eight nine ten]
```
Знайте и используйте. Подробнее о процентных (и не только процентных) литералах обязательно смотрите [здесь](http://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals).

Однако наилучшим образом процентные литералы смотрятся в хелперах. А именно здесь `slim` позволяет и вовсе так:
```ruby
- @result.each do |result|
  span.btn.btn-large class="btn-#{/\A\d+\Z/.match(result) ? 'danger' : 'success'}" style='margin:4px' = result
```

#### Миграции, ORM и CRUD в консоли
Чтобы не начинать создавать модели и миграции в пустоте, создадим модель для пользователей и приделаем к ней гем `devise`. Или приделаем ее к гему `devise`. [Devise gem](https://github.com/plataformatec/devise) — открываем, смотрим, ставим, привыкаем — с ним мы теперь надолго.

Там, конечно, все хорошо написано, но здесь все же продублируем:
```ruby
gem 'devise'
```
```
rails generate devise:install
```
```
rails generate devise User
```
```
rake db:migrate
```
Что где пишется и выполняется, вы все, конечно, помните. Если нет — нужная информация есть здесь выше или в readme `devise`.

Выполняем все, читаем логи, обращаем внимание на существенно обогатившийся каталог **/db/migrate** и файл **/db/schema.rb**. С этим каталогом и файлом теперь придется работать систематически.

Остальные функции `devise` оставим пока в покое, чтобы не отвлекаться и снова не растекаться мыслью по всем рельсам. Вместо этого поставим пока
```ruby
gem 'faker'
```
Вот его [GitHub](https://github.com/stympy/faker) с дивно интересным **readme**.

Теперь мы готовы создавать мнимых пользователей нашего приложения с правдоподобными данными. Открываем консоль и убеждаемся в определенности модели `User`:
```ruby
User.count
```
Отлично. Модель определена и содержит 0 записей. Так и должно быть.

Аккуратно создаем нового пользователя и выдаем ему адрес электронной почты:
```ruby
first_user = User.new
first_user.email = Faker::Internet.email
```
Пытаемся сохранить:
```ruby
first_user.save
```
Что-то не получается. Проверяем, всего ли хватает нашему первому пользователю, проходит ли он валидацию:
```ruby
first_user.valid?
```
Действительно, нет. Как узнать, чего не хватает:
```ruby
first_user.errors.full_messages.each { |i| puts i }
```
Так намного понятнее. С faker'ом пароль — не проблема совершенно:
```ruby
first_user.password = Faker::Internet.password
```
_(Что-то какие-то так себе пароли faker создает, без огонька...)_ Однако теперь это сработает:
```ruby
first_user.save
```
Итак, с методами записей `new` и `save` мы разобрались. Теперь освоим метод `create`, который делает и то, и другое сам, по дороге освоив минимальную ruby way автоматизацию:
```ruby
def create_user
  User.create(email: Faker::Internet.email,
  password: Faker::Internet.password)
end
```
Создавать пользователей теперь очень просто:
```ruby
7.times { create_user }
```
Чтобы они там не скучали.

У нас тоже дел еще полно: все на рельсах для тренировки **Twitter** пишут, а мы вот структурой данных **LiveJournal** вдохновимся для разнообразия. Пусть у нас у пользователя будет много постов и комментариев. Но все по порядку — сначала сделаем собственную миграцию, чтобы немного уточнить модель пользователя. Добавим ему имя, фамилию и флажки, админ ли он и не забанен ли он, случаем:
```
rails g migration AddFnameLnameAdminBannedToUsers fname:string lname:string admin:boolean banned:boolean
```
или можно воспользоваться генератором RubyMine. Просматриваем единственный сгенерированный файл и восхищаемся достигнутым взаимопониманием. Банзай:
```
rake db:migrate
```
Чтобы увидеть изменения из консоли, как правило, достаточно выполнить команду
```ruby
reload!
```
Иногда приходится выйти из консоли командой `exit` или `quit` и снова зайти: `rails c`.

Смотрим
```
User.all
```
и видим, что все, в общем, в порядке: имя и фамилию всякие анонимусы могут и не указывать, а вот `nil` в качестве значения `admin` и `banned` имеют серьезные шансы в скором времени поломать логику нашего приложения. Это обязательно нужно исправить. Переписываем миграцию:
```ruby
class AddFnameLnameAdminBannedToUsers < ActiveRecord::Migration
  def change
    add_column :users, :fname, :string
    add_column :users, :lname, :string
    add_column :users, :admin, :boolean, null: false, default: false
    add_column :users, :banned, :boolean, null: false, default: false
  end
end
```
И переделываем ее rake'ом:
```
rake db:migrate:redo
```
`User.all` подхватывает свершившиеся изменения даже без `reload!`.

Только вот вывод консоли выглядит что-то чересчур беспорядочным. Чтобы сберечь свое время и повысить уровень профессионализма, совершим героическую эпопею установки и настройки гема [hirb](https://github.com/cldwalker/hirb):
```ruby
gem 'hirb'
```
А вот после бандлера начинаются пляски с бубном. Чтобы заставить `hirb` работать с `pry`, создаем конфигурационный файл для `pry` (в командном интерпретаторе):
```bash
nano ~/.pryrc
```
и запиливаем туда
```ruby
begin
  require 'hirb'
rescue LoadError
  # Missing goodies, bummer
end

if defined? Hirb
  # Slightly dirty hack to fully support in-session Hirb.disable/enable toggling
  Hirb::View.instance_eval do
    def enable_output_method
      @output_method = true
      @old_print = Pry.config.print
      Pry.config.print = proc do |output, value|
        Hirb::View.view_or_page_output(value) || @old_print.call(output, value)
      end
    end

    def disable_output_method
      Pry.config.print = @old_print
      @output_method = nil
    end
  end

  Hirb.enable
end
```
Сохраняем, закрываем. Переписывание конфигов `hirb` — как раз те самые операции, для получения результатов которых нехобходимо именно выходить из консоли и запускать ее заново. Так и делаем. Пытаться понять приведенный выше фрагмент кода лучше в свободное от обучения на курсе время.

Зато `User.all` теперь смотрится куда как приличнее. А вот если бы еще отображать только нужные колонки — так вообще было бы хорошо. Не вопрос. в **/config** создаем `hirb.yml` и оформляем его примерно так:
```
:output:
  User:
    :options:
      :fields:
        - id
        - email
        - admin
        - banned
        - created_at
        - updated_at
```
После перезахода в консоль можно наслаждаться отображением `User.all`, опасно близким к совершенству.

Давайте-ка как-нибудь обзовем всех юзеров:
```ruby
User.all.each do |user|
  name = Faker::Name.name.split(' ')
  fname, lname = name[-2], name[-1]
  user.update(fname: fname, lname: lname)
end
```
и настроим отображение соответствующих полей:
```
:output:
  User:
    :options:
      :fields:
        - id
        - fname
        - lname
        - email
        - admin
        - banned
        - created_at
        - updated_at
```
На этом знакомство с `hirb` можно считать исчерпывающим.

Не забудем переопределить генератор юзеров, а то они так анонимусами и останутся:
```ruby
def create_user
  name = Faker::Name.name.split(' ')
  fname, lname = name[-2], name[-1]
  User.create(fname: fname, lname: lname,
  email: Faker::Internet.email,
  password: Faker::Internet.password)
end
```
Вернемся к ORM — создадим модель `Post`:
```
rails g model Post title:string content:text user:references
```
```
rake db:migrate
```
Просматривая созданные файлы, не устаем удивляться тому, как хорошо работает генератор рельсов — даже `belongs_to :user` в модель вписал. Теперь только `User`'у осталось добавить, что у него
```ruby
has_many :posts
```
Неужели руками будем посты создавать? Ничуть не бывало, это совсем не ruby way. Вот как надо:
```ruby
def create_post
  uids = User.all.map(&:id)
  Post.create(title: Faker::Lorem.sentence,
  content: Faker::Lorem.paragraph(2 + rand(8)),
  user_id: uids.sample)
end
```
И, как обычно:
```ruby
10.times { create_post }
```
`hirb` еще можно под это сконфигурировать:
```
:output:
  User:
    :options:
      :fields:
        - id
        - fname
        - lname
        - email
        - admin
        - banned
        - created_at
        - updated_at
  Post:
    :options:
      :fields:
        - id
        - title
        - content
        - user_id
```

А вот и ORM в действии:
```ruby
User.find(7).posts
```
```ruby
Post.find(10).user
```
Уничтожить юзера с id=3 вместе со всеми его постами:
```ruby
User.destroy(3)
```
Чтобы удаление связанных объектов проходило корректно, `destroy` нужно вызывать на модели, а не на записи.
```ruby
User.find(3).destroy
```
связанных объектов не удалит.

#### Getting real: контроллеры, скаффолдинг и немного предметной логики
Теперь, когда мы вдоволь наигрались с базой виртуальных персонажей и их виртуальных мнений, самое время сделать функциональность нашего учебного проекта более полной: добавить возможность создания сущностей через интерфейс приложения.

Вспомним про `devise` и сгенерируем-таки для него вьюхи:
```
rails generate devise:views
```
Теперь, если мы просто добавим в колонку над списком навигационных ссылок интуитивно понятный фрагмент
```ruby
- if signed_in?
  p = link_to 'Sign out', :destroy_user_session, method: :delete, class: %i[btn btn-block btn-large btn-warning]
- else
  p = link_to 'Sign in', :user_session, class: %i[btn btn-block btn-large btn-success]
  p = link_to 'Sign up', :new_user_registration, class: %i[btn btn-block btn-large btn-primary]
```
У нас сразу появится функциональность регистрации-входа-выхода пользователя. Спасибо `devise`, он очень простой и полезный.

Теперь имеет смысл запустить генератор скаффолда из бумажного пособия
```
rails g scaffold Comment title:string content:text user:references post:references
```
и внимательно прочитать сгенерированный код, особенно файл **comments_controller.rb**, при необходимости сверяясь с бумажным, опять же, пособием.

Сочтем скучные бытовые подробности, характерные для каждого контроллера, понятными и перейдем непосредственно к освоению важнейшего навыка при построении контроллеров — определения из параметров запроса только того, что необходимо, и полного исключения критически важных параметров из передачи через запросы. Для этого в самую первую очередь выпилим недрогнувшей рукой из `comment_params` упоминания `user_id` и `post_id`. Именно им двоим там совсем уж подчеркнуто не место:
```ruby
def comment_params
  params.require(:comment).permit(:title, :content)
end
```
Только так. Как экшн `create` комментариев узнает, кто автор комментария и какому сообщению он принадлежит, будем разбирать тщательно и неторопливо.

Пока поставим еще один хороший гем для создания форм (тоже от [plataformatec](https://github.com/plataformatec), как и `devise`) — [simple_form](https://github.com/plataformatec/simple_form):
```ruby
gem 'simple_form'
```
Тут же запустим генератор _(а вообще привыкаем читать мануалы)_:
```
rails generate simple_form:install --bootstrap
```
Теперь мы готовы к созданию минималистичного интерфейса для реализации нашей задачи. Контроллер сообщений все-таки сделать надо, хотя бы так:
```
rails g controller Posts index show
```
Выглядеть он должен примерно так:
```ruby
class PostsController < ApplicationController
  before_action :set_post, only: %i[show]
  before_action :authenticate_user!, only: %i[show]

  def index
    @posts = Post.all.includes(:user)
  end

  def show
    @comments = @post.comments.includes(:user)
    @comment = Comment.new
    user_session[:post_id] = @post.id
  end

  private

  def set_post
    @post = Post.find(params[:id])
  end
end
```
Здесь все знакомо по контроллеру из скаффолда, отдельно стоит упомянуть только то, что метод `authenticate_user!` добавлен гемом `devise`, да директива `includes` деятельно балансирует нагрузку и выхватывает из базы все, что нам понадобится для создания вьюхи.

А вот, собственно, и вьюхи — незатейливая **posts/index.html.slim**:
```ruby
h1 Posts index
table.table.table-striped
  - @posts.each do |post|
    tr
      td = "#{post.user.fname} #{post.user.lname}"
      td = link_to post.title, post
      td = post.created_at
```
Обратите внимание, как красиво задается адрес ссылки — достаточно просто указать элемент, чтобы получить ссылку на его `show`.

И весьма интересная **posts/show.html.slim**:
```ruby
h1 = @post.title
p = @post.content
h2 Comments:
dl
  - @comments.each do |comment|
    dt
      =' comment.title
      ' by
      span.label.label-success = comment.user.email
    dd = comment.content
h2 Add new comment
= simple_form_for @comment do |f|
  = f.input :title
  = f.input :content
  = f.submit
```
Обратите внимание на синтаксис использования `simple_form`. В мануале этого гема очень много интересного, обязательно уделите пристальное внимание.

И теперь, чтобы все это заработало, необходимо вернуться к **comments_controller.rb**:
```ruby
  def create
    @comment = current_user.comments.build(comment_params)
    @comment.post_id = user_session[:post_id]
    user_session.delete(:post_id)
    ...
```
Благодаря гему `devise` у нас есть доступ к сессии пользователя (`user_session`) и возможность создавать сущности от имени текущего пользователя. Внимательные читатели обратили внимание, когда мы при показе сообщения записывали его `id` в сессию пользователя.

Следует справедливости ради отметить, что ключ в сессии пользователя следовало бы назвать скорее `post_id_for_comment`, потому что контекст сообщения может быть использован где-то еще, но в целом пример передачи данных и через формы и запрос, и минуя их, можно считать законченным.

В практической работе по этому принципу можно будет построить более сложные схемы безопасной передачи данных, исключающие уязвимости от манипуляций параметрами запросов.

#### Javascript на рельсах
Чем лучше вы знакомы с `javascript`, тем больше ошибок в его реализации на рельсах вы можете сделать. В связи с этим нам нужно сделать несколько важных шагов по предотвращению некоторых из этих возможных ошибок.

Как вставить `javascript` на страницу rails-приложения. Возьмем, к примеру, **posts/show.html.slim** и будем над ней издеваться:
```
javascript:
  alert('Никогда так не делайте!');
```
Тому есть несколько причин. Во-первых, в мире rails принято использовать `coffeescript`. Не обязательно, но принято. Не вопрос:
```
coffee:
  alert "Никогда так не делайте, даже на coffescript!"
```
Еще `javascript` может использовать атрибуты вьюхи (`coffescript` ими давится при аналогичном синтаксисе):
```
javascript:
  alert("Никогда так не делайте, даже с «#{@post.title}»!");
```
Как бы ни был соблазнителен такой подход, все равно так не делайте. Чуть позже мы рассмотрим правильный способ решения задачи передачи параметров из `ruby` в `javascript`. Впрочем, к нему нужно подготовиться, и для начала переведем **application.js** на `coffeescript`. К `javascript` вы в любой момент сможете вернуться потом, если захотите.

Переименовываем **application.js** в **application.js.coffee**. Тут же нужно отметить, что в `javascript` комментарии обозначаются `//`, а в `coffescript` — `#`, и поэтому манифест включаемых файлов и каталогов с новым расширением должен теперь выглядеть примерно так:
```coffee
#= require jquery
#= require jquery_ujs
#= require twitter/bootstrap
#= require_tree .
```
Теперь мы немного поподбираем способы красиво покрасить с помощью `javascript` ссылки в разные цвета. Для этого нам среди прочего понадобится функция (этим фрагментом, кстати, можно пользоваться как шпаргалкой по объявлению функций в `coffeescript`):
```coffee
paintIt = (element, backgroundColor, textColor) ->
  element.style.backgroundColor = backgroundColor
  if textColor?
    element.style.color = textColor
```
По мере того, как наш `javascript` будет становиться все более ненавязчивым (unobtrusive), нам все больше и больше будет требоваться такого рода интерфейс, связывающий элементы DOM с функциями `javascript`:
```coffee
$ ->
  $("a[data-background-color]").click ->
    backgroundColor = $(this).data("background-color")
    textColor = $(this).data("text-color")
    paintIt(this, backgroundColor, textColor)
```
К слову, `$ ->` — так по-кофескриптовски будет `$(document).ready.function(...)`. С отступом можно будет писать то же, что и в скобках у этой `function()`. Довольно удобно.

А нам нужно освоить лучшие практики формирования ненавязчивых атрибутов в хелперах:
```ruby
p = link_to('Paint it red', 'javascript:void(0)', data: {:'background-color' => '#990000', :'text-color' => '#fff'})
p = link_to('Paint it green', 'javascript:void(0)', :'data-background-color' => '#009900')
p = link_to('Paint it blue', 'javascript:void(0)', :'data-background-color' => '#000099')
```
Сочтя тему ненавязчивого (unobtrusive) `javascript` раскрытой, перейдем к изучению JS-шаблонизатора rails, поставим гем [skim](https://github.com/jfirebaugh/skim):
```ruby
gem 'skim'
```
И обязательно рассмотрим пример из его `readme` и заодно дополним его одним важным моментом. Создадим каталог **templates** в **app/assets/**. Чтобы шаблоны из этого каталога были доступны, в манифестной части **application.js.coffee** зарегистрируем его:
```coffee
#= require_tree ../templates/
```
Именно об этой тонкости умалчивает `readme`, а валить jst-шаблоны в одну кучу js-файлами всего приложения и отдельных контроллеров ой как не хочется.

Однако сейчас все в порядке, и можно вернуться к примеру из `readme`. Создаем файл **test.jst.skim** в нашем каталоге **app/assets/templates** и пишем туда, собственно:
```
p Hello #{@world}!
```
Теперь в **application.js.coffee**
```coffee
  $("#skim-block").html(JST["test"]({world: "World"}))
```
Осталось только `#skim-block` куда-нибудь во вьюхе воткнуть, а то **Hello World** во всю `body` — это все-таки чересчур, у нас тут все-таки серьезный профессиональный курс.

Теперь освоим простой ajax-запрос (настолько простой, что до уровня шпаргалки не дотягивает):
```coffee
  $("a#comments-index").click ->
    $.ajax '/comments.json',
      type: 'GET',
      success: (data) ->
        $("div#skim-block").replaceWith(JST['comments']({comments: data}))
```
Внимательные читатели заметят, что этому запросу для отображения результатов потребуется **comments.jst.skim**. Вот и он:
```
dl
  - for comment in @comments
    dt = comment.title
    dd = comment.content
```
Все просто. И этот случай — исключение из правила не использовать `for`. Здесь другие итераторы просто не работают.

Приделываем ко вьюхе недостающие упоминаемые в `javascript` блоки и убеждаемся, что все работает.

Для полноты ощущений давайте создадим что-нибудь асинхронно и посмотрим заодно, как пробрасывать параметры из `ruby` в `javascript` и в какой-то мере наоборот. Ставим гем [gon](https://github.com/gazay/gon):
```ruby
gem 'gon'
```
Подключаем его ни много, ни мало в **application.html.slim**:
```
  = include_gon
```
В **posts_controller.rb** пишем:
```ruby
  def show
    @comments = @post.comments.includes(:user)
    @comment = Comment.new
    user_session[:post_id] = @post.id
    gon.push({:user_id => current_user.id,
              :post_id => @post.id})
  end
```
В **posts.js.coffee**:
```coffee
$ ->
  $("div#skim-block").html(JST['post'](user: gon.user_id, post: gon.post_id))
```
Не забываем ставить упомянутые в JS элементы DOM во вьюхи (`#skim-block` там куда-нибудь). И создавать упомянутые шаблоны тоже не забываем. В **post.jst.skim**:
```
p
  ' User to create comment:
  = @user
p
  ' Post to be commented:
  = @post
```
Тему передачи данных в JS можно считать раскрытой. Если вы собираетесь строить развесистые асинхронные интерфейсы, с гемом `gon` вам предстоит долгое и близкое знакомство.
Тем временем мы проверили контекст приложения, не передаваемый через параметры запросов, и можем переходить к сути асинхронного создания комментария. Добавим в **posts.js.coffee**:
```coffee
  $("a#ajax_submit").click ->
    $.ajax '/comments.json',
      type: 'POST',
      data:
        comment:
          title: $("input#comment_title")[0].value,
          content: $("textarea#comment_content")[0].value,
      success: (data) ->
        $("div#skim-block").replaceWith(data)
```
Обратите внимание, что мы используем для ввода уже имеющиеся во вьюхе поля, созданные с помощью `simple_form`. Вьюха к этому времени может выглядеть уже примерно так:
```ruby
h1 = @post.title
p = @post.content
h2 Comments:
dl
  - @comments.each do |comment|
    dt
      =' comment.title
      ' by
      span.label.label-success = comment.user.email
    dd = comment.content
h2 Add new comment
= simple_form_for @comment do |f|
  = f.input :title
  = f.input :content
#skim-block
p  = link_to('Create comment asynchronously', 'javascript:void(0)', id: :ajax_submit, class: %i[btn btn-block btn-large btn-primary])
```
Теперь остается только (на будущее) вооружиться более полной шпаргалкой по ajax-запросам на `coffeescript`:
```coffee
$.ajax '/yourUrlHere',
  data :
    key : 'value'
  success  : (res, status, xhr) ->
  error    : (xhr, status, err) ->
  complete : (xhr, status) ->
```
В самостоятельной работе по допиливанию адекватного поведения асинхронного интерфейса создания комментариев можно обойтись и сокращенным вариантом, уже встречавшимся выше.

#### Решения самостоятельных работ, которым по ряду технических причин лучше быть зафиксированными здесь
А то, к моему большому сожалению, желание сохранить интригу и возможность самостоятельного поиска оборачивается слишком большими потерями времени.

Прежде всего необходимо сделать контроллер, который выдаст в `json` все комментарии к данному в параметрах запроса сообщению. Пишем в **routes.rb**:
```ruby
  get 'comments_by_post/:id', to: 'comments#index'
```
Эта строка располагает дополнить контроллер `comments#index` инструкциями на случай прихода ключа `:id` в параметрах:
```ruby
  def index
    @comments = params[:id].present? ? Comment.where(post_id: params[:id]) : Comment.all
  end
```
Фрагмент вполне можно считать самокомментированным, здесь довольно ясно просматривается близость `ruby` к обычному английскому.

Придет в параметрах ключ `:id` или не придет, за выдачу данных в формате `json` будет отвечать все равно **app/views/comments/index.json.jbuilder**, который возвращает массив хэшей с данными запрошенных комментариев, поэтому шаблон **comments.jst.skim** сработает и здесь также, добавлять новый шаблон не нужно.

Заменяем во вьюхе **posts/show.html.slim** статичный вывод комментариев на контейнер для асинхронной загрузки:
```slim
h2 Comments:
/dl
/  - @comments.each do |comment|
/    dt
/      =' comment.title
/      ' by
/      span.label.label-success = comment.user.email
/    dd = comment.content
#comments-block
```
Вывод просто закомментирован. Он может нам еще пригодиться.

Теперь добавим в **posts.js.coffee** в часть `$ ->` код асинхронной загрузки комментариев с помощью нашего нового экшна:
```coffee
  $.ajax '/comments_by_post/' + gon.post_id + '.json',
    type: 'GET',
    success: (data) ->
      $("div#comments-block").html(JST['comments']({comments: data}))
```
И эту же операцию нужно будет проводить при каждом успешном создании комментария:
```coffee
  $("a#ajax_submit").click ->
    $.ajax '/comments.json',
      type: 'POST',
      data:
        comment:
          title: $("input#comment_title")[0].value,
          content: $("textarea#comment_content")[0].value,
      success: () ->
        $.ajax '/comments_by_post/' + gon.post_id + '.json',
          type: 'GET',
          success: (data) ->
            $("div#comments-block").html(JST['comments']({comments: data}))
```
Осталось только убрать из экшна **posts#show** строчку про
```ruby
    user_session.delete(:post_id)
```
убивающую всю асинхронность нашего интерфейса на корню (заодно, правда, показывающая, что синхронный интерфейс мы описали как раз очень правильно).

Все работает, но код выглядит громоздким и повторяющимся. Выносим загрузку комментариев в функцию, обращаем внимание на обязательные пустые скобки при объявлении и вызове функции без аргументов в `coffeescript`:
```coffee
refreshComments = () ->
  $.ajax '/comments_by_post/' + gon.post_id + '.json',
    type: 'GET',
    success: (data) ->
      $("div#comments-block").html(JST['comments']({comments: data}))

$ ->

  refreshComments()

  $("a#ajax_submit").click ->
    $.ajax '/comments.json',
      type: 'POST',
      data:
        comment:
          title: $("input#comment_title")[0].value,
          content: $("textarea#comment_content")[0].value,
      success: () ->
        refreshComments()
```
Да, так получше с точки зрения синтаксиса. С точки зрения производительности запускать дополнительный ajax-запрос, чтобы обработать результат предыдущего, очень странно и неразумно. Обычной практикой здесь является обработка ответа сервера в фазе `success`. Для этого, правда, в `json`-ответе успешного создания комментария нужно передавать не данные созданного комментария, как делает скаффолдовый контроллер по умолчанию, а данные всех комментариев к этому сообщению. В **comments#create** пишем:
```ruby
        format.json { render json: @comment.post.comments) }
```
Снова самокомментированный фрагмент на `ruby`, который вдобавок еще иллюстрирует и разительное отличие в восприятии человекоориентированного кода на `ruby` и машиноориентированного кода на `coffeescript`, который от неплохого, впрочем, синтаксического сахара более ясным для восприятия не становится. Хотя здесь утешает то, что на обычном `javascript` это все выглядело бы еще намного страшнее.

Теперь код асинхронного создания комментария может выглядеть так:
```coffee
  $("a#ajax_submit").click ->
    $.ajax '/comments.json',
      type: 'POST',
      data:
        comment:
          title: $("input#comment_title")[0].value,
          content: $("textarea#comment_content")[0].value,
      success: (data) ->
        $("div#comments-block").html(JST['comments']({comments: data}))
```
Букв стало больше, зато мы избавились от дополнительного ajax-запроса. Теперь все-таки хорошо бы закончить рефакторинг **posts.js.coffee** и сделать его семантически целостным и ясным:
```coffee
refreshComments = (data) ->
  $("div#comments-block").html(JST['comments']({comments: data}))

$ ->

  $.ajax '/comments_by_post/' + gon.post_id + '.json',
    type: 'GET',
    success: (data) ->
      refreshComments(data)

  $("a#ajax_submit").click ->
    $.ajax '/comments.json',
      type: 'POST',
      data:
        comment:
          title: $("input#comment_title")[0].value,
          content: $("textarea#comment_content")[0].value,
      success: (data) ->
        refreshComments(data)
```
Здесь мы выносим процедуру обновления комментариев в семантически верно названную функцию, которую вызываем в разных местах с разными параметрами, но нам и много лет спустя будет просто понять, что происходит в этом коде — всего-то благодаря верному именованию функции.

Теперь, когда у нас все работает, хорошо бы вернуться к выводу комментариев, каким он был в статичной вьюхе, с указанием адреса электронной почты автора. Для этого нужно этот адрес передавать в `json`. А вот ссылку на просмотр отдельного комментария можно как раз не передавать. С учетом этого вьюха **comments/index.json.jbuilder** должна выглядеть примерно так:
```ruby
json.array!(@comments) do |comment|
  json.extract! comment, :id, :title, :content, :user_id, :post_id
  json.user { json.email comment.user.email }
end
```
Это `ruby`, здесь все по-человчеcки и понятно, ORM это надежно здесь обеспечивает. Нам осталось отредактировать JS-шаблон **comments.jst.skim**:
```
dl
  - for comment in @comments
    dt
      =' comment.title
      ' by
      span.label.label-success = comment.user.email
    dd = comment.content
```
И добавить передачу данных пользователя в набор, передаваемый при создании комментария:
```ruby
        format.json { render json: @comment.post.comments.to_json(include: :user) }
```
Можно еще озаботиться производительностью и перечислить только используемые в отображении поля и комментария, и пользователя:
```ruby
        format.json { render json: @comment.post.comments.to_json(select: %i[title content], include: { user: { only: :email } } ) }
```
Дополнительно о развитии этого подхода и других интересных тонкостях генерации `json` на рельсах можно почитать [хабр](http://habrahabr.ru/post/152719/). Состояние особенной просветленности, как обычно на хабре, доставляют комментарии.

То есть, фактически, сейчас мы описываем одно и то же отображение одних и тех же сущностей в двух разных местах нашего проекта. Этого, конечно, лучше никогда не делать, но в целях улучшения производительности иногда приходится. Поэтому обязательно добавляем в оба места соответствующие комментарии:

**comments#create**:
```ruby
        format.json { render json: @comment.post.comments.to_json(select: %i[title content], include: { user: { only: :email } } ) }
        # Дублируется в views/comments/index.json.jbuilder, при изменении обязательно проверять соответствие!
```
**views/comments/index.json.jbuilder**:
```ruby
# Дублируется в comments#create, при изменении обязательно проверять соответствие!
json.array!(@comments) do |comment|
  json.extract! comment, :id, :title, :content, :user_id, :post_id
  json.user { json.email comment.user.email }
end
```
То есть, все это дублирование и комментирование делается только ради того, чтобы при создании комментария не гонять дополнительный запрос. Если этот аспект производительности вас не беспокоит, можно остановиться на варианте с дополнительным запросом, с которого мы начинали.
